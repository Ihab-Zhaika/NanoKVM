name: Build NanoKVM preview artifacts

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      build_os_image:
        description: 'Build flashable OS image (requires more time and resources)'
        required: false
        default: false
        type: boolean
      rebuild_docker:
        description: 'Force rebuild Docker image (skip cache)'
        required: false
        default: false
        type: boolean

concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  # Azure Container Registry configuration
  ACR_REGISTRY: ${{ secrets.ACR_REGISTRY }}
  ACR_IMAGE_NAME: nanokvm-builder
  ACR_IMAGE_TAG: latest
  # Base NanoKVM OS image for creating flashable images
  BASE_IMAGE_URL: https://github.com/sipeed/NanoKVM/releases/download/NanoKVM/20240702_NanoKVM_Rev1_0_0.img.xz

jobs:
  # Build Docker image using the reusable workflow
  docker-image:
    name: Docker Image
    uses: ./.github/workflows/docker-build.yml
    with:
      force_rebuild: ${{ github.event.inputs.rebuild_docker == 'true' }}
    secrets:
      ACR_REGISTRY: ${{ secrets.ACR_REGISTRY }}
      ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
      ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
      TOOLCHAIN_URL: ${{ secrets.TOOLCHAIN_URL }}

  # Build NanoKVM using Docker container
  build:
    name: Build NanoKVM components
    needs: docker-image
    runs-on: ubuntu-latest
    env:
      KVMAPP_WEB_PATH: server/web

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v2
        with:
          login-server: ${{ secrets.ACR_REGISTRY }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build with Docker container
        run: |
          docker run --rm \
            -v "${{ github.workspace }}:/workspace" \
            -v "${{ github.workspace }}/output:/workspace/output" \
            -e WORKSPACE=/workspace \
            -e OUTPUT_DIR=/workspace/output \
            "${{ needs.docker-image.outputs.image }}" \
            build-nanokvm

      - name: List build artifacts
        run: |
          echo "Build output:"
          ls -la output/
          echo ""
          echo "Packages:"
          ls -la output/*.tar.gz || true

      - name: Upload kvmapp update package
        uses: actions/upload-artifact@v4
        with:
          name: nanokvm-kvmapp-${{ github.sha }}
          path: output/nanokvm-kvmapp-update.tar.gz
          if-no-files-found: error

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nanokvm-build-${{ github.sha }}
          path: |
            output/nanokvm-artifacts.tar.gz
            output/kvmapp/
            output/tools/
          if-no-files-found: error

  build-os-image:
    name: Build flashable OS image
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.build_os_image }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install image tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y \
            xz-utils \
            kpartx \
            parted \
            e2fsprogs \
            dosfstools

      - name: Download kvmapp artifact
        uses: actions/download-artifact@v4.1.8
        with:
          name: nanokvm-kvmapp-${{ github.sha }}
          path: ./artifacts

      - name: Download base NanoKVM OS image
        run: |
          echo "Downloading base NanoKVM OS image..."
          curl -L -o base-image.img.xz "$BASE_IMAGE_URL"
          echo "Extracting image..."
          xz -d base-image.img.xz
          echo "Base image ready"
          ls -la base-image.img

      - name: Inject kvmapp into OS image
        run: |
          set -e
          
          # Setup loop device for the image
          echo "Setting up loop device..."
          LOOP_DEV=$(sudo losetup --find --show --partscan base-image.img)
          echo "Loop device: $LOOP_DEV"
          
          # Wait for partitions to appear
          sleep 2
          
          # List partitions
          echo "Partitions:"
          sudo fdisk -l "$LOOP_DEV"
          
          # Find the rootfs partition (usually partition 2)
          ROOTFS_PART="${LOOP_DEV}p2"
          if [ ! -b "$ROOTFS_PART" ]; then
            echo "Trying kpartx..."
            sudo kpartx -av base-image.img
            ROOTFS_PART="/dev/mapper/$(basename $LOOP_DEV)p2"
          fi
          
          # Mount rootfs
          echo "Mounting rootfs partition..."
          mkdir -p mnt/rootfs
          sudo mount "$ROOTFS_PART" mnt/rootfs
          
          # Backup existing kvmapp
          if [ -d "mnt/rootfs/kvmapp" ]; then
            echo "Backing up existing kvmapp..."
            sudo mv mnt/rootfs/kvmapp mnt/rootfs/kvmapp.bak
          fi
          
          # Extract new kvmapp
          echo "Installing new kvmapp..."
          sudo mkdir -p mnt/rootfs/kvmapp
          sudo tar -xzf artifacts/nanokvm-kvmapp-update.tar.gz -C mnt/rootfs/kvmapp
          
          # Set permissions
          sudo chmod -R 755 mnt/rootfs/kvmapp
          
          # Verify installation
          echo "Verifying installation..."
          ls -la mnt/rootfs/kvmapp/
          
          # Cleanup - these commands may fail if the device was not set up,
          # so we handle errors gracefully with logging
          echo "Cleaning up..."
          sudo umount mnt/rootfs
          
          # Detach loop device if it exists
          if [ -n "$LOOP_DEV" ]; then
            sudo losetup -d "$LOOP_DEV" 2>/dev/null || echo "Note: Loop device cleanup skipped (may already be detached)"
          fi
          
          # Remove kpartx mappings if they exist
          sudo kpartx -d base-image.img 2>/dev/null || echo "Note: kpartx cleanup skipped (mappings may not exist)"
          
          echo "kvmapp injection complete"

      - name: Compress final OS image
        run: |
          echo "Compressing final OS image..."
          VERSION="dev-$(echo ${{ github.sha }} | cut -c1-7)"
          OUTPUT_NAME="nanokvm-os-${VERSION}.img"
          mv base-image.img "$OUTPUT_NAME"
          xz -9 -T0 "$OUTPUT_NAME"
          
          echo "Final image created:"
          ls -la "${OUTPUT_NAME}.xz"
          
          # Generate checksum
          sha256sum "${OUTPUT_NAME}.xz" > "${OUTPUT_NAME}.xz.sha256"
          cat "${OUTPUT_NAME}.xz.sha256"

      - name: Upload OS image
        uses: actions/upload-artifact@v4
        with:
          name: nanokvm-os-image-${{ github.sha }}
          path: |
            nanokvm-os-*.img.xz
            nanokvm-os-*.img.xz.sha256
          if-no-files-found: error
