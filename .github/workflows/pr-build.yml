name: Build NanoKVM preview artifacts

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      build_os_image:
        description: 'Build flashable OS image (requires more time and resources)'
        required: false
        default: false
        type: boolean
      rebuild_docker:
        description: 'Force rebuild Docker image (skip cache)'
        required: false
        default: false
        type: boolean
      upload_to_azure:
        description: 'Upload artifacts to Azure Storage'
        required: false
        default: true
        type: boolean

concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  # Azure Container Registry configuration
  ACR_REGISTRY: ${{ secrets.ACR_REGISTRY }}
  ACR_IMAGE_NAME: nanokvm-builder
  ACR_IMAGE_TAG: latest
  # Base NanoKVM OS image for creating flashable images
  BASE_IMAGE_URL: https://github.com/sipeed/NanoKVM/releases/download/NanoKVM/20240702_NanoKVM_Rev1_0_0.img.xz
  # Azure Storage configuration
  AZURE_STORAGE_CONTAINER: ${{ secrets.AZURE_STORAGE_CONTAINER }}

jobs:
  # Build Docker image using the reusable workflow
  docker-image:
    name: Docker Image
    uses: ./.github/workflows/docker-build.yml
    with:
      force_rebuild: ${{ github.event.inputs.rebuild_docker == 'true' }}
    secrets:
      ACR_REGISTRY: ${{ secrets.ACR_REGISTRY }}
      ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
      ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
      TOOLCHAIN_URL: ${{ secrets.TOOLCHAIN_URL }}

  # Build NanoKVM using Docker container
  build:
    name: Build NanoKVM components
    needs: docker-image
    runs-on: ubuntu-latest
    env:
      KVMAPP_WEB_PATH: server/web

    steps:
      - name: Debug secrets availability
        run: |
          echo "=== Debugging Secrets Availability ==="
          echo "Checking if secrets are populated in the build job..."
          echo ""
          if [ -z "${{ secrets.ACR_REGISTRY }}" ]; then
            echo "❌ ACR_REGISTRY secret is NOT populated!"
          else
            echo "✅ ACR_REGISTRY secret is populated (value hidden for security)"
            echo "   Length: $(echo -n '${{ secrets.ACR_REGISTRY }}' | wc -c) characters"
          fi
          echo ""
          if [ -z "${{ secrets.ACR_USERNAME }}" ]; then
            echo "❌ ACR_USERNAME secret is NOT populated!"
          else
            echo "✅ ACR_USERNAME secret is populated"
          fi
          echo ""
          if [ -z "${{ secrets.ACR_PASSWORD }}" ]; then
            echo "❌ ACR_PASSWORD secret is NOT populated!"
          else
            echo "✅ ACR_PASSWORD secret is populated"
          fi
          echo ""
          echo "=== Docker Image Workflow Output ==="
          echo "docker-image.outputs.image: '${{ needs.docker-image.outputs.image }}'"
          echo "docker-image.outputs.image_tag: '${{ needs.docker-image.outputs.image_tag }}'"
          echo ""
          echo "=== Environment Info ==="
          echo "GitHub Event: ${{ github.event_name }}"
          echo "GitHub Ref: ${{ github.ref }}"
          echo "GitHub Repository: ${{ github.repository }}"
          echo "=================================="

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v2
        with:
          login-server: ${{ secrets.ACR_REGISTRY }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Determine Docker image
        id: docker-image
        env:
          ACR_REGISTRY: ${{ secrets.ACR_REGISTRY }}
          WORKFLOW_IMAGE: ${{ needs.docker-image.outputs.image }}
        run: |
          # First try to use the output from docker-image job
          if [ -n "$WORKFLOW_IMAGE" ] && [ "$WORKFLOW_IMAGE" != "/:latest" ] && [ "$WORKFLOW_IMAGE" != "/nanokvm-builder:latest" ]; then
            echo "Using image from docker-image workflow: $WORKFLOW_IMAGE"
            echo "image=${WORKFLOW_IMAGE}" >> $GITHUB_OUTPUT
          # Otherwise construct the image name directly
          elif [ -n "$ACR_REGISTRY" ]; then
            IMAGE="${ACR_REGISTRY}/nanokvm-builder:latest"
            echo "Constructed image name: $IMAGE"
            echo "image=${IMAGE}" >> $GITHUB_OUTPUT
          else
            echo "ERROR: Cannot determine Docker image."
            echo "Neither workflow output nor ACR_REGISTRY secret is available."
            echo ""
            echo "Please ensure these secrets are set in repository settings:"
            echo "  - ACR_REGISTRY: Your Azure Container Registry URL (e.g., myregistry.azurecr.io)"
            echo "  - ACR_USERNAME: Registry username"
            echo "  - ACR_PASSWORD: Registry password"
            exit 1
          fi

      - name: Build with Docker container
        env:
          DOCKER_IMAGE: ${{ steps.docker-image.outputs.image }}
        run: |
          echo "Using Docker image: $DOCKER_IMAGE"
          docker run --rm \
            -v "${{ github.workspace }}:/workspace" \
            -v "${{ github.workspace }}/output:/workspace/output" \
            -e WORKSPACE=/workspace \
            -e OUTPUT_DIR=/workspace/output \
            "$DOCKER_IMAGE" \
            build-nanokvm

      - name: List build artifacts
        run: |
          echo "Build output:"
          ls -la output/
          echo ""
          echo "Packages:"
          ls -la output/*.tar.gz || true

      - name: Upload kvmapp update package
        uses: actions/upload-artifact@v4
        with:
          name: nanokvm-kvmapp-${{ github.sha }}
          path: output/nanokvm-kvmapp-update.tar.gz
          if-no-files-found: error

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nanokvm-build-${{ github.sha }}
          path: |
            output/nanokvm-artifacts.tar.gz
            output/kvmapp/
            output/tools/
          if-no-files-found: error

      - name: Upload artifacts to Azure Storage
        if: ${{ (github.event_name == 'workflow_dispatch' && inputs.upload_to_azure) || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}
        env:
          AZURE_STORAGE_CONNECTION_STRING: ${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}
          AZURE_STORAGE_CONTAINER: ${{ secrets.AZURE_STORAGE_CONTAINER }}
        run: |
          # Skip if connection string is not set
          if [ -z "$AZURE_STORAGE_CONNECTION_STRING" ]; then
            echo "AZURE_STORAGE_CONNECTION_STRING not set, skipping Azure upload"
            exit 0
          fi
          
          # Install Azure CLI if not present
          if ! command -v az &> /dev/null; then
            curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          fi
          
          CONTAINER="${AZURE_STORAGE_CONTAINER:-nanokvm-builds}"
          VERSION="dev-$(echo ${{ github.sha }} | cut -c1-7)"
          BRANCH_NAME="${{ github.ref_name }}"
          UPLOAD_PATH="${BRANCH_NAME}/${VERSION}"
          
          echo "Uploading artifacts to Azure Storage..."
          echo "Container: $CONTAINER"
          echo "Path: $UPLOAD_PATH"
          
          # Upload kvmapp package
          az storage blob upload \
            --container-name "$CONTAINER" \
            --name "${UPLOAD_PATH}/nanokvm-kvmapp-update.tar.gz" \
            --file output/nanokvm-kvmapp-update.tar.gz \
            --overwrite
          
          # Upload full artifacts package
          az storage blob upload \
            --container-name "$CONTAINER" \
            --name "${UPLOAD_PATH}/nanokvm-artifacts.tar.gz" \
            --file output/nanokvm-artifacts.tar.gz \
            --overwrite
          
          echo "Artifacts uploaded successfully to Azure Storage"
          echo "Download URL pattern: https://<storage-account>.blob.core.windows.net/$CONTAINER/${UPLOAD_PATH}/"

  build-os-image:
    name: Build flashable OS image
    needs: build
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.build_os_image }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install image tools
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y \
            xz-utils \
            kpartx \
            parted \
            e2fsprogs \
            dosfstools

      - name: Download kvmapp artifact
        uses: actions/download-artifact@v4.1.8
        with:
          name: nanokvm-kvmapp-${{ github.sha }}
          path: ./artifacts

      - name: Download base NanoKVM OS image
        run: |
          echo "Downloading base NanoKVM OS image..."
          curl -L -o base-image.img.xz "$BASE_IMAGE_URL"
          echo "Extracting image..."
          xz -d base-image.img.xz
          echo "Base image ready"
          ls -la base-image.img

      - name: Inject kvmapp into OS image
        run: |
          set -e
          
          # Setup loop device for the image
          echo "Setting up loop device..."
          LOOP_DEV=$(sudo losetup --find --show --partscan base-image.img)
          echo "Loop device: $LOOP_DEV"
          
          # Wait for partitions to appear
          sleep 2
          
          # List partitions
          echo "Partitions:"
          sudo fdisk -l "$LOOP_DEV"
          
          # Find the rootfs partition (usually partition 2)
          ROOTFS_PART="${LOOP_DEV}p2"
          if [ ! -b "$ROOTFS_PART" ]; then
            echo "Trying kpartx..."
            sudo kpartx -av base-image.img
            ROOTFS_PART="/dev/mapper/$(basename $LOOP_DEV)p2"
          fi
          
          # Mount rootfs
          echo "Mounting rootfs partition..."
          mkdir -p mnt/rootfs
          sudo mount "$ROOTFS_PART" mnt/rootfs
          
          # Backup existing kvmapp
          if [ -d "mnt/rootfs/kvmapp" ]; then
            echo "Backing up existing kvmapp..."
            sudo mv mnt/rootfs/kvmapp mnt/rootfs/kvmapp.bak
          fi
          
          # Extract new kvmapp
          echo "Installing new kvmapp..."
          sudo mkdir -p mnt/rootfs/kvmapp
          sudo tar -xzf artifacts/nanokvm-kvmapp-update.tar.gz -C mnt/rootfs/kvmapp
          
          # Set permissions
          sudo chmod -R 755 mnt/rootfs/kvmapp
          
          # Verify installation
          echo "Verifying installation..."
          ls -la mnt/rootfs/kvmapp/
          
          # Cleanup - these commands may fail if the device was not set up,
          # so we handle errors gracefully with logging
          echo "Cleaning up..."
          sudo umount mnt/rootfs
          
          # Detach loop device if it exists
          if [ -n "$LOOP_DEV" ]; then
            sudo losetup -d "$LOOP_DEV" 2>/dev/null || echo "Note: Loop device cleanup skipped (may already be detached)"
          fi
          
          # Remove kpartx mappings if they exist
          sudo kpartx -d base-image.img 2>/dev/null || echo "Note: kpartx cleanup skipped (mappings may not exist)"
          
          echo "kvmapp injection complete"

      - name: Compress final OS image
        run: |
          echo "Compressing final OS image..."
          VERSION="dev-$(echo ${{ github.sha }} | cut -c1-7)"
          OUTPUT_NAME="nanokvm-os-${VERSION}.img"
          mv base-image.img "$OUTPUT_NAME"
          xz -9 -T0 "$OUTPUT_NAME"
          
          echo "Final image created:"
          ls -la "${OUTPUT_NAME}.xz"
          
          # Generate checksum
          sha256sum "${OUTPUT_NAME}.xz" > "${OUTPUT_NAME}.xz.sha256"
          cat "${OUTPUT_NAME}.xz.sha256"
          
          # Save output name for later steps
          echo "OUTPUT_NAME=${OUTPUT_NAME}" >> $GITHUB_ENV

      - name: Upload OS image
        uses: actions/upload-artifact@v4
        with:
          name: nanokvm-os-image-${{ github.sha }}
          path: |
            nanokvm-os-*.img.xz
            nanokvm-os-*.img.xz.sha256
          if-no-files-found: error

      - name: Upload OS image to Azure Storage
        if: ${{ inputs.upload_to_azure }}
        env:
          AZURE_STORAGE_CONNECTION_STRING: ${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}
          AZURE_STORAGE_CONTAINER: ${{ secrets.AZURE_STORAGE_CONTAINER }}
        run: |
          # Skip if connection string is not set
          if [ -z "$AZURE_STORAGE_CONNECTION_STRING" ]; then
            echo "AZURE_STORAGE_CONNECTION_STRING not set, skipping Azure upload"
            exit 0
          fi
          
          # Install Azure CLI if not present
          if ! command -v az &> /dev/null; then
            curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          fi
          
          CONTAINER="${AZURE_STORAGE_CONTAINER:-nanokvm-builds}"
          VERSION="dev-$(echo ${{ github.sha }} | cut -c1-7)"
          BRANCH_NAME="${{ github.ref_name }}"
          UPLOAD_PATH="${BRANCH_NAME}/${VERSION}"
          
          echo "Uploading OS image to Azure Storage..."
          echo "Container: $CONTAINER"
          echo "Path: $UPLOAD_PATH"
          
          # Upload OS image
          az storage blob upload \
            --container-name "$CONTAINER" \
            --name "${UPLOAD_PATH}/${OUTPUT_NAME}.xz" \
            --file "${OUTPUT_NAME}.xz" \
            --overwrite
          
          # Upload checksum
          az storage blob upload \
            --container-name "$CONTAINER" \
            --name "${UPLOAD_PATH}/${OUTPUT_NAME}.xz.sha256" \
            --file "${OUTPUT_NAME}.xz.sha256" \
            --overwrite
          
          echo "OS image uploaded successfully to Azure Storage"
          echo "Download URL: https://<storage-account>.blob.core.windows.net/$CONTAINER/${UPLOAD_PATH}/${OUTPUT_NAME}.xz"
